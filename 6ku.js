// Если перечислить все натуральные числа меньше 10, кратные 3 или 5, то получим 3, 5, 6 и 9. Сумма этих кратных равна 23.

// Завершите решение так, чтобы оно возвращало сумму всех чисел, кратных 3 или 5, ниже переданного числа.

// Кроме того, если число отрицательное, верните 0.

// Примечание: если число кратно и 3, и 5, считайте его только один раз .

function solution(number) {
    let sum = 0;
    for (let i = 1; i < number; i++) {
        if (i % 3 === 0 || i % 5 === 0) {
            sum += i;
        }
    }
    return sum;
}

console.log(solution(10))

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает ту же строку, но все слова, содержащие пять или более букв, перевёрнуты (как в названии этого ката). Передаваемые строки будут состоять только из букв и пробелов. Пробелы будут учитываться только при наличии нескольких слов.

// Примеры:

// "Hey fellow warriors"  --> "Hey wollef sroirraw" 
// "This is a test        --> "This is a test" 
// "This is another test" --> "This is rehtona test"

function spinWords(string){
  const wordArray = string.split(' ')
  for (i = 0; i < wordArray.length; i++) {
    if (wordArray[i].length >=5) {
        wordArray[i] = wordArray[i].split('').reverse().join('')
    }
  }
  return(wordArray.join(' '))
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Вы, вероятно, знакомы с системой «лайков» на Facebook и других страницах. Люди могут ставить отметки «Нравится» публикациям в блогах, фотографиям и другим материалам. Мы хотим создать текст, который будет отображаться рядом с таким материалом.

// Реализуйте функцию, которая принимает массив имён людей, которым понравился товар. Функция должна возвращать отображаемый текст, как показано в примерах:

// []                                -->  "no one likes this"
// ["Peter"]                         -->  "Peter likes this"
// ["Jacob", "Alex"]                 -->  "Jacob and Alex like this"
// ["Max", "John", "Mark"]           -->  "Max, John and Mark like this"
// ["Alex", "Jacob", "Mark", "Max"]  -->  "Alex, Jacob and 2 others like this"
// Примечание: для 4 и более имен число "and 2 others"просто увеличивается.

function likes(names) {
  const singleSuffix =  "likes this"
  const pluralSuffix =  "like this"
  let message
  switch (names.length) {
      case 0:
      message = `no one ${singleSuffix}`
      break;
      case 1:
      message = `${names[0]} ${singleSuffix}`
      break;
      case 2:
      message = `${names[0]} and ${names[1]} ${pluralSuffix}`
      break;
      case 3:
      message = `${names[0]}, ${names[1]} and ${names[2]} ${pluralSuffix}`
      break;
      default:
      message = `${names[0]}, ${names[1]} and ${names.length - 2} others ${pluralSuffix}`
  }
  return message
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Дан массив целых чисел, найдите то, которое встречается нечетное количество раз.

// Всегда будет только одно целое число, которое встречается нечетное количество раз.

// Примеры
// [7]должен вернуть 7, так как встречается 1 раз (что нечетно).
// [0]должен вернуть 0, так как встречается 1 раз (что нечетно).
// [1,1,2]должен вернуть 2, так как встречается 1 раз (что нечетно).
// [0,1,0,1,0]должен вернуть 0, так как встречается 3 раза (что нечетно).
// [1,2,2,3,3,3,4,3,3,3,2,2,1]должен вернуть 4, так как встречается 1 раз (что нечетно).


function findOdd(numbers) {
  const countMap = {};
  let oddOccurrenceNumber;

  numbers.forEach((number) => {
    countMap[number] = countMap[number] ? countMap[number] + 1 : 1;
  });

  for (const number in countMap) {
    if (countMap[number] % 2 !== 0) {
      oddOccurrenceNumber = Number(number);
    }
  }

  return oddOccurrenceNumber;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Реализуйте функцию, вычисляющую разницу между двумя списками. Функция должна удалять все вхождения элементов из первого списка ( a), присутствующие во втором списке ( b). Порядок элементов в первом списке должен сохраняться в результате.

// Примеры
// Если a = [1, 2]и b = [1], то результат должен быть [2].

// Если a = [1, 2, 2, 2, 3]и b = [2], то результат должен быть [1, 3].

function arrayDiff(a, b) {
  let result = []
  for (i = 0; i < a.length; i++) {
    if (!(b.includes(a[i]))) {
      result.push(a[i])
    }
  }
  return result
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Дано n, вычислите сумму цифр числа n. Если полученное значение содержит более одной цифры, продолжайте сокращать, пока не получится однозначное число. Входные данные будут неотрицательным целым числом.

// Примеры
//     16  -->  1 + 6 = 7
//    942  -->  9 + 4 + 2 = 15  -->  1 + 5 = 6
// 132189  -->  1 + 3 + 2 + 1 + 8 + 9 = 24  -->  2 + 4 = 6
// 493193  -->  4 + 9 + 3 + 1 + 9 + 3 = 29  -->  2 + 9 = 11  -->  1 + 1 = 2

function digitalRoot(n) {
  let arr = n.toString().split('')
  let result = arr.reduce((akk, item) => {
       return akk + +item
  }, 0)
  if (result.toString().length >= 2) {
      return digitalRoot(result)
  }
  return result
}

console.log(digitalRoot(1235))

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Напишите функцию, которая принимает массив из 10 целых чисел (от 0 до 9) и возвращает строку этих чисел в виде номера телефона.

// Пример
// createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"
// Для выполнения этого задания возвращенный формат должен быть правильным.

// Не забудьте пробел после закрывающихся скобок!

function createPhoneNumber(numbers){
  return `(${numbers.slice(0,3).join('')}) ${numbers.slice(3,6).join('')}-${numbers.slice(6).join('')}`
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Вам дан массив (длиной не менее 3 элементов, но может быть и очень большим), содержащий целые числа. Массив либо полностью состоит из нечётных целых чисел, либо полностью из чётных целых чисел, за исключением одного целого числа N. Напишите метод, который принимает массив в качестве аргумента и возвращает этот «выброс» N.

// Примеры
// [2, 4, 0, 100, 4, 11, 2602, 36] -->  11 (the only odd number)

// [160, 3, 1719, 19, 11, 13, -21] --> 160 (the only even number)

function findOutlier(integers){
  let countEven = 0
  for (let i=0; i<3; i++) {
    if (integers[i]%2 === 0) {
      countEven+=1
    }
  }
  if (countEven >=2) {
    return integers.find(el => el%2 !==0)
  }
  else {
    return integers.find(el => el%2 === 0)
  }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Подсчитайте количество дубликатов
// Напишите функцию, которая возвращает количество различных буквенно-цифровых символов (без учёта регистра), встречающихся во входной строке более одного раза. Можно предположить, что входная строка содержит только буквы (как заглавные, так и строчные) и цифры.

// Пример
// "abcde" -> 0 # no characters repeats more than once
// "aabbcde" -> 2 # 'a' and 'b'
// "aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
// "неделимость" -> 1 # 'i' occurs six times
// "Неделимости" -> 2 # 'i' occurs seven times and 's' occurs twice
// "aA11" -> 2 # 'a' and '1'
// "ABBA" -> 2 # 'A' and 'B' each occur twice

const a = 'aaAbBBc3'

function duplicateCount(text){
  const arr = text.split('')
  const obj = {}
  let count = 0
  arr.forEach((el)=>{
    if (obj[el.toLowerCase()]) {
      obj[el.toLowerCase()]++
    } else {
      obj[el.toLowerCase()] = 1
    }
  })

  for (let key in obj) {
    if (obj[key] > 1) {
      count++
    }
  }
  return count
}
 console.log(duplicateCount(a))

 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//  Цель этого упражнения — преобразовать строку в новую строку, где каждый символ в новой строке "("встречается только один раз в исходной строке или ")"встречается несколько раз. При определении дубликата символа не учитывайте регистр.

// Примеры
// "din"      =>  "((("
// "recede"   =>  "()()()"
// "Success"  =>  ")())())"
// "(( @"     =>  "))((" 


 const b = 'aaAbBBc3'

function duplicateEncode(word){
    const lowerArr = word.toLowerCase().split('')
    const newArr = []

    lowerArr.forEach((e, i) => {
        lowerArr.filter((el) => el === e).length > 1 ? newArr[i] = ')' : newArr[i] = '('
    })
    return newArr.join('');
}

console.log(duplicateEncode(b))

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Вы живёте в городе Картезия, где все дороги представляют собой идеальную сетку. 
// Вы приехали на десять минут раньше назначенного времени, поэтому решили воспользоваться возможностью и немного прогуляться. 
// Город предоставляет своим жителям приложение Walk Generating на телефоны — каждое нажатие кнопки отправляет вам массив однобуквенных строк, 
// представляющих направления для прогулки (например, ['n', 's', 'w', 'e']). Вы всегда проходите только один квартал на каждую букву (направление) и знаете, 
// что вам потребуется одна минута, чтобы пересечь один городской квартал, поэтому создайте функцию, которая вернёт true, 
// если предложенное приложением время прогулки займёт ровно десять минут (вы же не хотите опоздать или опоздать!), и, конечно же, вернёт вас в исходную точку. 
// В противном случае верните false .

// Примечание : вы всегда получите корректный массив, содержащий случайный набор букв, обозначающих направление (только «n», «s», «e» или «w»). 
// Он никогда не вернёт вам пустой массив (это не прогулка, это стояние на месте!).

const c = ['n','s', 'w', 'e', 'e']

function isValidWalk(walk) {
   const obj = {}
   walk.forEach((el) => {
    obj[el] = (obj[el] || 0) +1
   })

   return (walk.length === 10 && obj['n'] === obj['s'] && obj['w'] === obj['e'])
}

console.log(isValidWalk(c))

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Добро пожаловать.

// В этом ката вам необходимо, имея заданную строку, заменить каждую букву ее позицией в алфавите.

// Если в тексте есть что-то, что не является буквой, проигнорируйте это и не возвращайте.

// "a" = 1, "b" = 2, и т. д.

// Пример
// Input = "The sunset sets at twelve o' clock."
// Output = "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"

const d = 'abcdz'
function alphabetPosition(text) {
  const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
  let result = []
  for (const char of text.toLowerCase()) {
     if (alphabet.includes(char)) {
      result.push((alphabet.indexOf(char)) + 1)
     }
  }

  return result.join(' ');
}

console.log(alphabetPosition(d))

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Напишите функцию, persistenceкоторая принимает положительный параметр numи возвращает его мультипликативную устойчивость, то есть количество раз, которое необходимо умножить цифры, numпока не получится однозначная цифра.

// Например (Вход -> Выход) :

// 39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit, there are 3 multiplications)
// 999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2, there are 4 multiplications)
// 4 --> 0 (because 4 is already a one-digit number, there is no multiplication)

function persistence(num) {
   if (num.toString().length === 1) {
    return 0
   } else {
    let arr = num.toString().split('')
    let res = arr.reduce((akk, el) => {
       return akk*(+el)
    }, 1)
    return 1+persistence(res)
   }
}

console.log(persistence(56))

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Дополните метод/функцию так, чтобы он преобразовывал слова, разделённые тире/подчёркиванием, в «верблюжий» регистр . 
// Первое слово в выводе должно быть написано с заглавной буквы только в том случае, если исходное слово было написано 
// с заглавной буквы (так называемый «верхний верблюжий регистр», также часто называемый «паскалевским регистром»). 
// Последующие слова должны всегда начинаться с заглавной буквы.

// Примеры
// "the-stealth-warrior"преобразуется в"theStealthWarrior"

// "The_Stealth_Warrior"преобразуется в"TheStealthWarrior"

// "The_Stealth-Warrior"преобразуется в"TheStealthWarrior"

let s = "the-stealth-warrior"

function toCamelCase(str){
   let arr = str.split(/[_-]/)
   for (let i = 1; i < arr.length; i++) {
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1)
   }
   return arr.join('')
}

console.log(toCamelCase(s))

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Нарциссическое число (или число Армстронга) — это положительное число, 
// представляющее собой сумму своих цифр, каждая из которых возведена в степень, 
// соответствующую количеству цифр в данной системе счисления. В этой Кате мы ограничимся десятичной системой счисления (основание 10).

// Например, возьмем 153 (3 цифры), что является нарциссическим:

//     1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
// и 1652 (4 цифры), что не является:

//     1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
// Задача:

// Ваш код должен возвращать значение true или false (не «true» и «false») в зависимости от того, 
// является ли заданное число нарциссическим числом в десятичной системе счисления.

function narcissistic(value) {
  const pow = value.toString().length
  const num = value.toString().split('').reduce((akk, el)=>{
        return akk + (+el)**pow
  }, 0)
  return value === num
}